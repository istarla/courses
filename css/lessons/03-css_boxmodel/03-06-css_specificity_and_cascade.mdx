# CSS Specificity and The Cascade
Today we tackle two fundamental concepts that determine how CSS rules
are applied and how conflicts between rules are resolved:
**The Cascade** and **Specificity**.
Understanding these is key to writing predictable and maintainable CSS.

## The Cascade

The C in CSS stands for Cascading. The cascade is an algorithm that
browsers use to determine which CSS rule applies to an element when
multiple rules could potentially style it. The cascade considers three
main factors in this order:

1. **Importance (Origin):** CSS rules can come from
   different sources (origins). The cascade prioritizes them as follows
   (from highest to lowest priority):
   * Transition declarations
   * User agent stylesheet declarations with `!important`
   * Author stylesheet declarations (your CSS) with
     `!important`
   * Animation declarations
   * Author stylesheet normal declarations (your CSS)
   * User agent stylesheet normal declarations (browser defaults)
   * Inherited values from parent elementsThe `!important` flag on a declaration gives it higher
   precedence within its origin. However, using
   `!important` excessively is generally discouraged as it can
   make CSS harder to debug and override.
2. **Specificity:** If multiple declarations from the same
   origin and importance try to style the same property on an element,
   the declaration with the more specific selector wins. We'll cover
   specificity in detail next.
3. **Source Order:** If two declarations have the same
   importance and specificity, the one that appears later in the CSS code
   (or later in the linked stylesheets) wins. The last rule defined is
   applied.

```css
/* Example of Source Order */
p { color: blue; }
p { color: red; } /* This rule wins because it's later */

/* Example of Importance */
p { color: green !important; } /* This rule will likely win over the red one, regardless of source order (within author styles) */
p { color: orange; }
```

## Specificity

Specificity is a weight or score that a browser calculates for each CSS
selector to determine which rule to apply when multiple rules target the
same element and property, and have the same importance. The selector
with the highest specificity score "wins."

Specificity is typically represented as a three-column value (or
sometimes four, including inline styles): (IDs,
Classes/Attributes/Pseudo-classes, Elements/Pseudo-elements).

### Calculating Specificity:
      <table class="min-w-full bg-white specificity-table my-4">
        <thead>
          <tr>
            <th>**Selector Type**</th>
            <th>**Specificity Value (A, B, C)**</th>
            <th>**Example**</th>
            <th>**Score**</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Inline Styles</td>
            <td>(Considered highest, sometimes noted as 1,0,0,0)</td>
            <td><code>&lt;p style="color: pink;"&gt;</code></td>
            <td>Wins over selector-based styles</td>
          </tr>
          <tr>
            <td>ID Selectors</td>
            <td>(A) Adds 1 to the first column (e.g., 1,0,0)</td>
            <td><code>#myId</code></td>
            <td>1,0,0</td>
          </tr>
          <tr>
            <td>Class Selectors, Attribute Selectors, Pseudo-classes</td>
            <td>(B) Adds 1 to the second column (e.g., 0,1,0)</td>
            <td>
              <code>.myClass</code>, <code>[type="text"]</code>,
              <code>:hover</code>
            </td>
            <td>0,1,0 (each)</td>
          </tr>
          <tr>
            <td>Element Selectors, Pseudo-elements</td>
            <td>(C) Adds 1 to the third column (e.g., 0,0,1)</td>
            <td><code>p</code>, <code>::before</code></td>
            <td>0,0,1 (each)</td>
          </tr>
          <tr>
            <td>
              Universal Selector (<code>*</code>), Combinators (<code>+</code>,
              <code>&gt;</code>, <code>~</code>, space),
              <code>:not()</code> itself
            </td>
            <td colspan="3">
              These do not add to specificity (though selectors inside
              <code>:not()</code> do).
            </td>
          </tr>
        </tbody>
      </table>

**Comparison:** When comparing two specificities, compare
column by column from left to right (A, then B, then C). The first
column with a higher value determines the more specific selector. For
example, `1,0,0` is more specific than `0,50,0`.

### Specificity Examples:

      <div class="example-html">
        <div class="specificity-example">
          <p id="unique-para" class="special-text intro">
            This is a paragraph for specificity testing.
          </p>
        </div>
      </div>
```css
/* Example 1 */
p { color: blue; }                 /* Specificity: 0,0,1 */
.special-text { color: green; }    /* Specificity: 0,1,0 (Wins over p) */
#unique-para { color: purple; }    /* Specificity: 1,0,0 (Wins over .special-text and p) */

/* Example 2 */
div.main p.intro { color: red; }    /* Specificity: 0 (div) + 1 (.main) + 0 (p) + 1 (.intro) = 0,2,2 */
div#content p { color: orange; }    /* Specificity: 1 (#content) + 0 (div) + 0 (p) = 1,0,2 (Wins due to ID) */

/* Example 3: Inline style always wins (unless !important is used in stylesheet) */
/* HTML:

Text

*/
/* The text will be pink. */
```

The paragraph in the example above will be purple because the ID
selector (`#unique-para`) has the highest specificity among
the stylesheet rules. If an inline style was added, that would override
the ID selector.

### The important Rule

Appending `!important` to a CSS declaration makes that
declaration override any other declarations for that property on that
element, regardless of specificity or source order. However,
`!important` does not affect the specificity calculation
itself; it's a separate layer in the cascade.

```css
#myElement { color: blue; }
p#myElement { color: green; } /* More specific, so green wins */
p.someClass#myElement { color: red !important; } /* Red wins due to !important */
p { color: purple !important; } /* If #myElement is a p, purple would win over green but NOT red,
                                   because the red rule also has !important and is more specific
                                   among the !important rules. */
```

**When to use `!important`:**

* Overriding styles from third-party libraries or user agent
  stylesheets when no other method works.
* Utility classes that are meant to take absolute precedence (e.g.,
  `.hidden { display: none !important; }`).
* During development for quick testing (but remove it afterward if
  possible).

Overusing `!important` can lead to "specificity wars" and
make your CSS very difficult to maintain. Try to rely on well-structured
CSS and specificity rules first.

## Inheritance

Some CSS properties, when applied to an element, are inherited by its
child elements by default (e.g., color,
font-family, line-height). Other properties
are not inherited (e.g., border, padding,
width).

Inherited values have the lowest precedence in the cascade, effectively
having zero specificity. A directly applied rule to an element will
always override an inherited value, regardless of the inherited rule's
specificity.

You can explicitly control inheritance with keywords:

* **inherit**: Forces an element to inherit the value of a property from its
  parent.
* **initial**: Sets the property to its initial (default) value as defined by the
  CSS specification.
* **unset**: Acts as `inherit` if the property is normally inherited,
  or as initial if it's not.
* **revert**: Resets the property to the value established by the previous
  cascade origin (e.g., user agent stylesheet).

```css
body {
  font-family: Arial, sans-serif;
  color: #333; /* This color will be inherited by most text elements */
}

.sidebar {
  font-family: "Georgia", serif; /* Overrides inherited Arial */
  color: inherit; /* Explicitly inherits body's color: #333 */
  border: 1px solid #ccc; /* Not inherited by children of .sidebar */
}

.sidebar h2 {
  font-family: inherit; /* Inherits Georgia from .sidebar */
  color: initial; /* Resets color to its browser default (likely black) */
}
```

{/* // import Quiz from '../../../components/Quiz.js'
// import cssMCQs from '../quiz-data/css_specifity.js'

// <section id="quiz-time"></section>
// <Quiz questions={cssMCQs} /> */}